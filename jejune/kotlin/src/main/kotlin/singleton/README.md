# Kotlin Singleton Pattern 구현 방법

## 1. Object Declaration (객체 선언)

### 특징
- 코틀린에서 가장 간단하고 권장되는 싱글톤 구현 방식
- 컴파일 타임에 싱글톤 보장
- object 선언의 인스턴스를 클래스 로딩 시점에 단 한 번만 생성하기 때문에 스레드 세이프(Thread-Safe)

### 장점
- 구현이 매우 간단하고 명확함
- 자동으로 지연 초기화 지원
- 추가 코드 없이 싱글톤 패턴 구현 가능
- 메모리 효율성이 높음

### 단점
- 앱 시작 시 즉시 메모리에 로드됨
- 상속이 불가능
- 생성자 파라미터 전달 불가
- 테스트하기 어려울 수 있음


## 2. Companion Object 싱글톤

### 특징
- 클래스 내부에 싱글톤 로직 구현
- 이중 검사 잠금(Double-Checked Locking) 사용
- 필요할 때 인스턴스 생성

### 장점
- 더 많은 제어와 유연성 제공
- 동적 초기화 가능
- 생성자 로직 추가 가능
- 상속 및 인터페이스 구현 가능

### 단점
- Object 선언보다 구현이 복잡함
- 명시적인 동기화 메커니즘 필요
- 초기화 로직에 더 많은 주의 필요

## 3. 클래식 자바 스타일 싱글톤
### 특징
- 명시적 생성자 제어
- 이중 검사 잠금(Double-Checked Locking) 사용
- 가장 전통적인 싱글톤 구현 방식

### 장점
- 최대한의 제어와 유연성
- 복잡한 초기화 로직 구현 가능
- 다양한 초기화 전략 사용 가능

### 단점
- 구현이 가장 복잡함
- 보일러플레이트 코드 필요
- 스레드 세이프티 보장을 위해 추가 코드 필요
- 성능에 약간의 오버헤드 발생

### 주의사항
- 싱글톤 사용은 신중하게 고려해야 함
- 의존성 주입(Dependency Injection)을 대안으로 고려
- 과도한 싱글톤 사용은 애플리케이션 아키텍처를 복잡하게 만들 수 있음

## 스프링의 싱글톤 패턴 사용 예시
## 1. 스프링 프레임워크의 싱글톤 빈 (Bean)
```kotlin
@Service
class UserService(
    // 스프링에 의해 싱글톤으로 관리됨
    private val userRepository: UserRepository
) {

    fun findAllUsers(): List<User> {
        return userRepository.findAll()
    }
}
```
### 스프링 싱글톤 빈의 특징
- 기본적으로 애플리케이션 컨텍스트당 단 하나의 인스턴스 생성
- @Scope 어노테이션으로 싱글톤 범위 조정 가능
- 스레드 세이프하지 않은 상태를 가진 빈은 주의 필요
