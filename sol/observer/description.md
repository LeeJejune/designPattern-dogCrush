## 옵저버 패턴
: 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many)의존성을 정의

- 주제 (subject)는 동일한 인터페이스를 써서 옵저버에게 연락
- Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여할 수 있음
- 주제는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 관해 전혀 모름(느슨한 결합)
- 방식 : 1. 주제 -> 옵저버에게 데이터 보내기(푸시 방식), 2. 옵저버가 데이터를 가져오기(풀 방식 - 더 옳음)


Q. 푸쉬 방식이 옳은가?
-> 옵저버 패턴에서 푸쉬 방식을 사용하게 되면, 옵저버가 수동적으로 업데이트가 되게 된다.
업데이트 후, 출력이라던지의 행동을 원한다면 이것은 주제에서 실행이 된다거나 아니면 주제가 옵저버를 호출하는 로직(update)에서 실행이 된다.
주제는 단순한 주제일 뿐이고, 실제로 사용되는 개체는 옵저버가 될텐데 이 권한을 뺏기는게 옳은 것인가 라는 생각?

Q. 풀 방식이 옳은가?
-> 주제 내부에서 옵저버를 관리하던 푸쉬 방식과 달리, 풀 방식에서는 주제 - 옵저버를 등록해야하므로 주제 -> 옵저버를 알고, 옵저버가 자신이 원하는 타이밍에 컨트롤 하기 위해 옵저버 -> 주제를 알아야한다.
(책에서는 getter를 사용하면 된다고 하였지만 static이 아닌 이상 의존성은 옵저버 내부에 주입되어야 한다.)
또한 옵저버에 주제를 넣어서 생성하는 방법 (Observer observer = new Observer(subject);)은 oberver 자체의 객체로서의 컨트롤 하기 보다는 내부의 연관관계를 맺기 위한 불 필요한 방법처럼도 여겨진다.
'풀 방식'이 과연 느슨한 결합을 만드는 방법이 맞는가?

=> 
1. "옵저버가 주제를 알고 있어야 한다." : 완벽한 느슨한 결합이 아님.
2. 
```
Observer observer = new Observer(subject); 
```
보다는 조금 더 인터페이스나 이벤트 시스템을 활용하여 결합도를 낮추는 방식으로 구현할 수 있음
3. 다만 푸쉬 방식보다 풀 방식은 '옵저버(대상)가 원하는 시점에 가져올 수 있다'라는 자율성이 더 높으므로 좋다고 평가되는 듯 함.